# Rolodex 4.0 Build Programme

## Purpose
Rolodex 4.0 elevates the audit outcomes and the 3.0 action plan into a delivery-ready build programme. The goal is to ship a lightweight, trustworthy capture experience with an enterprise-grade backend and documentation stack that aligns with Chrome extension best practices.

## Vision
- **Zero-friction capture** – The Chrome extension collects context and punts it to a `/capture` workspace where designers can review and edit before saving.
- **Production-ready services** – The backend must run locally and in staging without secret sprawl, with deterministic tests and graceful degradation when optional AI/storage providers are missing.
- **Designer-grade library** – The library page consumes the real API, supports filtering, and maintains a polished presentation even when the API falls back to demo data.

## Architectural Tenets
1. **Fail-safe dependencies** – Optional vendors (Supabase, OpenAI) must never prevent local execution. Fallback behaviour is explicit and observable.
2. **Portable persistence** – Default to SQLite for local/test execution while staying compatible with Postgres. Schema bootstrap happens automatically on startup.
3. **Test-first delivery** – Every new service slice ships with pytest coverage using the ASGI test client, proving the CRUD flows and regression guards.
4. **Document before code** – Each step lists the expected documentation updates and developer commands so the next engineer can reproduce the environment.

## Step-by-step Programme

### Step 1 – Foundations & Environment Hardening
1. **Task 1.1 – Bootstrap schema & demo data**
   - Create a bootstrap module that runs on FastAPI startup, ensuring the minimum SQLite/Postgres schema exists and optionally seeding demo items for local exploration.
2. **Task 1.2 – Resilient storage service**
   - Refactor `backend/storage.py` to lazily initialise Supabase/OpenAI clients, fall back to no-op behaviour when credentials or packages are missing, and expose capability flags to the API layer.

### Step 2 – Backend Feature Layer
1. **Task 2.1 – SQLAlchemy data layer**
   - Replace raw SQL strings with SQLAlchemy table metadata and queries for items/projects, ensuring compatibility with SQLite and Postgres and enabling typed inserts/filters.
2. **Task 2.2 – API regression tests**
   - Add pytest scenarios covering create/list/filter items and project linking flows using the ASGI client with dependency overrides for storage.

### Step 3 – Capture & Library Experience
1. **Task 3.1 – Capture workspace**
   - Add a `/capture` route in the Next.js app with a refined form that accepts context parameters, calls the new `api.createItem` helper, and provides inline feedback.
2. **Task 3.2 – Library integration polish**
   - Replace the hard-coded demo token with environment-driven configuration, wire the list/search helpers to the real API, and retain graceful fallbacks when the backend is unreachable.

### Step 4 – Documentation & Enablement
1. **Task 4.1 – Enterprise documentation refresh**
   - Update `README.md`, `DEVELOPMENT.md`, and related docs with setup instructions, configuration tables, and capture/library walkthroughs aligned to 4.0.
2. **Task 4.2 – Test & operations checklist**
   - Document required test commands, CI expectations, and manual verification steps so QA/ops can promote builds confidently.

## Deliverables
- Updated backend with automatic schema bootstrap, optional dependencies guarded, and SQLAlchemy-powered routers.
- Next.js capture workspace and library flow wired to the 4.0 backend with environment-based configuration.
- Pytest coverage for items/project APIs proving CRUD and linking flows.
- Refreshed documentation describing local setup, environment variables, and chrome-extension best practices for the lightweight trigger strategy.

## Acceptance Criteria
- FastAPI boots without Supabase/OpenAI credentials and seeds demo data when enabled.
- `/api/items` and `/api/projects` endpoints pass the new regression tests on SQLite.
- `frontend/app/capture/page.tsx` renders the capture form, submits to the API, and surfaces success/error states.
- `frontend/app/page.tsx` reads tokens/base URL from environment variables with a documented fallback strategy.
- Documentation changes include setup tables, runbooks, and command references.
